# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""The MP2InitialPoint class to compute an initial point for the VQE Ansatz parameters."""

from __future__ import annotations

import numpy as np

from qiskit_nature.properties.second_quantization.electronic import ParticleNumber, ElectronicEnergy
from qiskit_nature.properties.second_quantization.electronic.bases import ElectronicBasis
from qiskit_nature.circuit.library import UCC
from qiskit_nature.properties.second_quantization.second_quantized_property import (
    GroupedSecondQuantizedProperty,
)

from .initial_point import InitialPoint


class MP2InitialPoint(InitialPoint):
    """Moller-Plesset 2nd order initial point generator.

    A class for computing the Moller-Plesset 2nd order (MP2) corrections to use
    as an initial point for VQE alongside a UCC ansatz.

    The MP2 calculation requires `orbital_energies` from the `ElectronicEnergy`
    in the driver result.

    An MP2InitialPoint uses the same excitations as generated by UCC to
    ensure that the coefficients are mapped correctly.

    The coefficients and energy deltas are computed when the object is
    initialized. The `initial_point` property may then be used with VQE.

    Only initial point values that correspond to double-excitations will be
    non-zero.
    """

    def __init__(self) -> None:
        super().__init__()
        self.threshold = 1e-12
        self._corrections: dict[str, tuple[float, float]] = None

    @property
    def driver_result(self) -> GroupedSecondQuantizedProperty:
        """The driver result."""
        return self._driver_result

    @driver_result.setter
    def driver_result(self, result: GroupedSecondQuantizedProperty) -> None:
        """The driver result."""

        electronic_energy = result.get_property(ElectronicEnergy)
        self.electronic_energy = electronic_energy

        particle_number = result.get_property(ParticleNumber)
        self.num_spin_orbitals = particle_number.num_spin_orbitals

        self._driver_result = result

    @property
    def ansatz(self) -> UCC:
        """The UCC ansatz."""
        return self._ansatz

    @ansatz.setter
    def ansatz(self, ans: UCC) -> None:
        """The UCC ansatz."""
        # Operators must be built early to compute excitation list.
        _ = ans.operators
        self.excitations = ans.excitation_list
        self._ansatz = ans

    @property
    def num_spin_orbitals(self) -> int:
        """The number of spin orbitals."""
        return self._num_spin_orbitals

    @num_spin_orbitals.setter
    def num_spin_orbitals(self, num_spin_orbs: int) -> None:
        """The number of spin orbitals.

        Raises:
            ValueError: For non-positive-definite input.
        """
        if num_spin_orbs <= 0:
            raise ValueError("The number of spin orbitals must be greater than zero.")
        self._num_spin_orbitals = num_spin_orbs

    @property
    def electronic_energy(self) -> ElectronicEnergy:
        """The ElectronicEnergy property."""
        return self._electronic_energy

    @electronic_energy.setter
    def electronic_energy(self, elec: ElectronicEnergy) -> None:
        """The ElectronicEnergy property.

        Raises:
            ValueError: If ElectronicEnergy is missing orbital energies.
        """
        orbital_energies = elec.orbital_energies
        if orbital_energies is None:
            raise ValueError("The orbital energies are missing from the electronic energy.")

        self._orbital_energies = orbital_energies
        self._integral_matrix = elec.get_electronic_integral(ElectronicBasis.MO, 2).get_matrix()
        self._reference_energy = elec.reference_energy
        self._electronic_energy = elec

    @property
    def excitations(self) -> list[tuple[tuple[int, ...], tuple[int, ...]]]:
        """The list of excitations."""
        return self._excitations

    @excitations.setter
    def excitations(self, exs: list[tuple[tuple[int, ...], tuple[int, ...]]]):
        """The list of excitations."""
        # TODO: Validate excitation list as is done in UCC?
        self._excitations = exs

    @property
    def threshold(self) -> float:
        """The energy threshold for MP2 computation.

        Computed initial point and energy deltas will be set to
        zero if their value is below this threshold.
        """
        return self._threshold

    @threshold.setter
    def threshold(self, thr: float) -> None:
        """The energy threshold for MP2 computation.

        Computed initial point and energy deltas will be set to
        zero if their value is below this threshold.
        """
        if thr < 0.0:
            raise ValueError("The energy threshold cannot be negative.")
        self._threshold = thr

    @property
    def initial_point(self) -> np.ndarray:
        """The MP2 coefficients as an initial_point."""
        return np.asarray([val[0] for val in self._corrections.values()])

    @property
    def energy_deltas(self) -> np.ndarray:
        """The MP2 energy correction deltas for each excitation."""
        return np.asarray([val[1] for val in self._corrections.values()])

    @property
    def energy_delta(self) -> float:
        """The MP2 delta energy correction for the molecule."""
        return sum(self.energy_deltas)

    @property
    def energy(self) -> float:
        """The absolute MP2 energy for the molecule."""
        return self._reference_energy + self.energy_delta

    def get_initial_point(
        self, driver_result: GroupedSecondQuantizedProperty, ansatz: UCC
    ) -> np.ndarray:
        """
        Args:
            driver_result: the second quantization properties from the driver.
            ansatz: the UCC ansatz.

        Return:
            The computed initial point.
        """
        self.driver_result = driver_result
        self.ansatz = ansatz
        self._corrections = self._compute_corrections()
        return self.initial_point

    def _compute_corrections(
        self,
    ) -> dict[str, tuple[float, float]]:
        """Compute the MP2 coefficients and energy corrections for each double excitation.

        Non-double excitations will have zero coefficient and energy delta.

        Returns:
            Dictionary with MP2 coefficients and energy_deltas for each excitation.
        """
        corrections = {}
        for excitation in self._excitations:
            if len(excitation[0]) == 2:
                # MP2 needs double excitations.
                coeff, e_delta = self._compute_correction(excitation)
            else:
                # Leave single excitations unchanged.
                coeff, e_delta = 0.0, 0.0

            corrections[str(excitation)] = (coeff, e_delta)

        return corrections

    def _compute_correction(
        self, excitation: tuple[tuple[int, ...], tuple[int, ...]]
    ) -> tuple[float, float]:
        """Compute the MP2 coefficient and energy corrections given a double excitation.

        Each double excitation given by [i,a,j,b] has a coefficient computed using
            coeff = -(2 * T[i,a,j,b] - T[i,b,j,a)/(E[b] + E[a] - E[i] - E[j])
        where E is the orbital energy.
        and an energy delta given by
            e_delta = coeff * T[i,a,j,b]

        All the computations are done using the molecule orbitals but the indices used
        in the excitation information passed in and out are in the block spin orbital
        numbering as normally used by the nature module:
          - alpha runs from 0 to num_orbitals - 1,
          - beta runs from num_orbitals to num_orbitals * 2 - 1.

        Args:
            excitations: Sequence of excitations.

        Returns:
            Correction coefficients and energy deltas.
        """
        # Since spins are the same drop to MO indexing
        num_orbitals = self._num_spin_orbitals // 2
        i = excitation[0][0] % num_orbitals
        j = excitation[0][1] % num_orbitals
        a = excitation[1][0] % num_orbitals
        b = excitation[1][1] % num_orbitals

        tiajb = self._integral_matrix[i, a, j, b]
        tibja = self._integral_matrix[i, b, j, a]

        num = 2 * tiajb - tibja
        denom = (
            self._orbital_energies[b]
            + self._orbital_energies[a]
            - self._orbital_energies[i]
            - self._orbital_energies[j]
        )
        coeff = -num / denom
        coeff = coeff if abs(coeff) > self._threshold else 0
        e_delta = coeff * tiajb
        e_delta = e_delta if abs(e_delta) > self._threshold else 0

        return coeff, e_delta
