# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""The MP2InitialPoint class to compute an initial point for the VQE Ansatz parameters."""

from __future__ import annotations

import numpy as np
from qiskit_nature.exceptions import QiskitNatureError

from qiskit_nature.properties.second_quantization.electronic import ElectronicEnergy
from qiskit_nature.properties.second_quantization.electronic.bases import ElectronicBasis
from qiskit_nature.circuit.library import UCC
from qiskit_nature.properties.second_quantization.electronic.integrals.electronic_integrals import (
    ElectronicIntegrals,
)
from qiskit_nature.properties.second_quantization.second_quantized_property import (
    GroupedSecondQuantizedProperty,
)

from .initial_point import InitialPoint


class MP2InitialPoint(InitialPoint):
    """Moller-Plesset 2nd order initial point generator.

    A class for computing the Moller-Plesset second order (MP2) corrections to use as an initial
    point with a VQE algorithm alongside a UCC ansatz.

    The MP2 calculation requires the two-body molecular orbital matrix, the orbital energies,
    and (optionally) the Hartree-Fock reference energy from ``ElectronicEnergy``, which must be
    set via `grouped_property`.

    An MP2InitialPoint uses the same excitations generated by the UCC `ansatz` to ensure that
    the coefficients are mapped correctly in the initial point array. Only initial point values that
    correspond to double-excitations will be non-zero.

    The coefficients and energy deltas are computed using the ``compute`` method, which requires
    ``grouped_property`` and ``ansatz`` to be set either via their properties or the `compute`
    arguments. Thereafter, they can be accessed via the ``x`` and ``energy_deltas`` properties,
    respectively.
    """

    def __init__(self, threshold: float = 1e-12) -> None:
        super().__init__()
        self.threshold: float = threshold

        self._grouped_property: GroupedSecondQuantizedProperty | None = None
        self._integral_matrix: np.ndarray | None = None
        self._orbital_energies: np.ndarray | None = None
        self._reference_energy: float = 0.0

        self._ansatz: UCC | None = None
        self._excitations_list: list[tuple[tuple[int, ...], tuple[int, ...]]] | None = None

        self._corrections: dict[str, tuple[float, float]] | None = None
        self._missing_input_error_message: str = (
            "Not enough information has been provided to compute the MP2 corrections. "
            "Set `grouped_property` and `ansatz` or call `compute` with them as arguments."
        )

    @property
    def grouped_property(self) -> GroupedSecondQuantizedProperty:
        """The grouped property."""
        return self._grouped_property

    @grouped_property.setter
    def grouped_property(self, grouped_property: GroupedSecondQuantizedProperty) -> None:
        """The grouped property.

        The grouped property is required to contain the ElectronicEnergy, which must contain
        the two-body molecular orbital matrix and the orbital energies. Optionally, it will also
        use the Hartree-Fock reference energy to compute the absolute energy.

        Raises:
            QiskitNatureError: If the ``ElectronicEnergy`` is missing or the two-body molecular
                orbital matrix or the orbital energies are missing from ``ElectronicEnergy``.
        """

        electronic_energy: ElectronicEnergy | None = grouped_property.get_property(ElectronicEnergy)
        if not isinstance(electronic_energy, ElectronicEnergy):
            raise QiskitNatureError(f"ElectronicEnergy not in grouped property: {grouped_property}")

        two_body_mo_integral: ElectronicIntegrals | None = (
            electronic_energy.get_electronic_integral(ElectronicBasis.MO, 2)
        )
        if not isinstance(two_body_mo_integral, ElectronicIntegrals):
            raise QiskitNatureError(
                f"Two body MO electronic integral not in grouped property: {grouped_property}"
            )

        orbital_energies: np.ndarray | None = electronic_energy.orbital_energies
        if not isinstance(orbital_energies, np.ndarray):
            raise QiskitNatureError(f"Orbital energies not in grouped property: {grouped_property}")

        # Invalidate any previous computation.
        self._corrections = None

        self._integral_matrix = two_body_mo_integral.get_matrix()
        self._orbital_energies = orbital_energies
        self._reference_energy = electronic_energy.reference_energy if not None else 0.0
        self._grouped_property = grouped_property

    @property
    def ansatz(self) -> UCC:
        """The UCC ansatz."""
        return self._ansatz

    @ansatz.setter
    def ansatz(self, ansatz: UCC) -> None:
        """The UCC ansatz."""

        # Operators must be built early to compute excitation list.
        _ = ansatz.operators

        # Invalidate any previous computation.
        self._corrections = None

        self._excitations_list = ansatz.excitation_list
        self._ansatz = ansatz

    @property
    def threshold(self) -> float:
        """The energy threshold for MP2 computation.

        Computed initial point and energy deltas will be set to zero if their absolute value is
        below this threshold.
        """
        return self._threshold

    @threshold.setter
    def threshold(self, threshold: float) -> None:
        """The energy threshold for MP2 computation.

        Computed initial point and energy deltas will be set to zero if their absolute value is
        below this threshold.
        """
        try:
            threshold = abs(float(threshold))
        except TypeError:
            threshold = 0.0

        # Invalidate any previous computation.
        self._corrections = None

        self._threshold = float(threshold)

    @property
    def excitations(self) -> list[tuple[tuple[int, ...], tuple[int, ...]]]:
        """The list of excitations."""
        return self._excitations_list

    @excitations.setter
    def excitations(self, excitations: list[tuple[tuple[int, ...], tuple[int, ...]]]):
        """The list of excitations.

        Setting this will overwrite the excitation list from the ansatz.
        """
        # Invalidate any previous computation.
        self._corrections = None

        self._excitations_list = excitations

    def to_numpy_array(self) -> np.ndarray:
        """Convert the computed initial point to a numpy array.

        Raises:
            QiskitNatureError: If the initial point has not and cannot yet be computed.

        Returns:
            The initial point as a numpy array of MP2 correction coefficients.
        """
        if self._corrections is None:
            if self._grouped_property is None or self._ansatz is None:
                raise QiskitNatureError(self._missing_input_error_message)
            self.compute()
        return np.asarray([value[0] for value in self._corrections.values()])

    def compute(
        self,
        grouped_property: GroupedSecondQuantizedProperty | None = None,
        ansatz: UCC | None = None,
    ) -> None:
        """Computes an MP2-informed initial point for the VQE algorithm.

        Computes the Moller-Plesset second order (MP2) corrections to use as an initial point with
        a VQE algorithm alongside a UCC ansatz.

        The MP2 calculation requires the two-body molecular orbital matrix, the orbital energies,
        and the Hartree-Fock reference energy from the ``ElectronicEnergy`` in the grouped
        property.

        An MP2InitialPoint uses the same excitations as generated by the UCC ansatz to ensure that
        the coefficients are mapped correctly in the initial point. Only initial point values that
        correspond to double-excitations will be non-zero.

        Args:
            grouped_property: A grouped second-quantized property that is required to contain the
                ``ElectronicEnergy``. Additionally, ``ElectronicEnergy`` is required to contain the
                two-body molecular orbital matrix and the orbital energies, and the Hartree-Fock
                reference energy. If this has already been set, it doesn't need to be passed again
                as an argument. If it is passed, it will overwrite the previous grouped property.
                If it is not passed and has not been set an error will be raised.
            ansatz: The UCC ansatz. If this has already been set, it doesn't need to be passed as
                an argument. If it is passed, it will overwrite the previous grouped property. If
                it is not passed and has not been set an error will be raised.

        Raises:
            QiskitNatureError: If ``grouped_property`` and/or ``ansatz`` are not set.

        Return:
            The computed initial point.
        """
        if not isinstance(grouped_property, GroupedSecondQuantizedProperty):
            if not isinstance(self._grouped_property, GroupedSecondQuantizedProperty):
                raise QiskitNatureError("Cannot compute. `grouped_property` has not been set.")
        else:
            self.grouped_property = grouped_property

        if not isinstance(ansatz, UCC):
            if not isinstance(self._ansatz, UCC):
                raise QiskitNatureError("Cannot compute. `ansatz` has not been set.")
        else:
            self.ansatz = ansatz

        self._corrections = self._compute_corrections()

    def _compute_corrections(
        self,
    ) -> dict[str, tuple[float, float]]:
        """Compute the MP2 coefficients and energy corrections for each double excitation.

        Tuples of the coefficients and energy deltas are stored in a dictionary with a string of
        the corresponding excitation. This dictionary isn't directly exposed to the user, but is
        retained for internal clarity and validation. Non-double excitations will have zero
        coefficient and energy delta.

        Returns:
            Dictionary with MP2 coefficients and energy_deltas for each excitation.
        """
        corrections = {}
        for excitation in self._excitations_list:
            if len(excitation[0]) == 2:
                # Compute MP2 corrections using double excitations.
                coefficient, energy_delta = self._compute_correction(excitation)
            else:
                # No corrections for single, triple, and higher excitations.
                coefficient, energy_delta = 0.0, 0.0

            corrections[str(excitation)] = (coefficient, energy_delta)

        return corrections

    def _compute_correction(
        self, excitation: tuple[tuple[int, ...], tuple[int, ...]]
    ) -> tuple[float, float]:
        """Compute the MP2 coefficient and energy corrections given a double excitation.

        Each double excitation indexed by ::math`i,a,j,b` has a correction coefficient,

        ..math::
            c_{i,a,j,b} = -\\frac{2 T_{i,a,j,b} - T_{i,b,j,a}}{E_b + E_a - E_i - E_j},

        where ::math::`E` is the orbital energy and ::math::`T` is the integral matrix.
        And an energy delta,

        ..math..
            \\Delta E_{i, a, j, b} = c_{i,a,j,b} T_{i,a,j,b}.

        These computations use molecular orbitals, but the indices used in the excitation
        information passed in and out use the block spin orbital numbering common to Qiskit Nature:
          - ::math::`\\alpha` runs from ``0`` to ``num_molecular_orbitals - 1``,
          - ::math::`\\beta` runs from ``num_molecular_orbitals`` to
            ``num_molecular_orbitals * 2 - 1``.

        Args:
            excitations: List of excitations.

        Returns:
            Correction coefficients and energy deltas.
        """
        integral_matrix = self._integral_matrix
        orbital_energies = self._orbital_energies
        threshold = self._threshold

        # Infer the number of molecular orbitals from the MO matrix.
        num_molecular_orbitals: int = integral_matrix.shape[0]

        i = excitation[0][0] % num_molecular_orbitals
        j = excitation[0][1] % num_molecular_orbitals
        a = excitation[1][0] % num_molecular_orbitals
        b = excitation[1][1] % num_molecular_orbitals

        expectation_value_iajb = integral_matrix[i, a, j, b]
        expectation_value_ibja = integral_matrix[i, b, j, a]

        expectation_value = 2 * expectation_value_iajb - expectation_value_ibja
        orbital_energy_delta = (
            orbital_energies[b] + orbital_energies[a] - orbital_energies[i] - orbital_energies[j]
        )
        correction_coeff = -expectation_value / orbital_energy_delta
        correction_coeff = correction_coeff if abs(correction_coeff) > threshold else 0.0

        energy_delta = correction_coeff * expectation_value_iajb
        energy_delta = energy_delta if abs(energy_delta) > threshold else 0.0

        return correction_coeff, energy_delta

    def get_energy_deltas(self) -> np.ndarray:
        """The individual MP2 energy correction deltas for each excitation.

        Raises:
            QiskitNatureError: If the initial point has not and cannot yet be computed.

        Returns:
            The individual MP2 energy correction deltas for each excitation.
        """
        if self._corrections is None:
            if self._grouped_property is None or self._ansatz is None:
                raise QiskitNatureError(self._missing_input_error_message)
            self.compute()
        return np.asarray([value[1] for value in self._corrections.values()])

    def get_energy_delta(self) -> float:
        """The overall MP2 energy correction for the molecule."""
        return self.get_energy_deltas().sum()

    def get_energy(self) -> float:
        """The absolute MP2 energy for the molecule.

        If the reference energy has not been set from the ElectronicEnergy. This will return the
        MP2
        """
        return self._reference_energy + self.get_energy_delta()
