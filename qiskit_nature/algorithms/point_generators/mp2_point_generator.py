# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""The MP2PointGenerator class to compute an initial point for VQE."""

from typing import Dict, List, Tuple

import numpy as np

from qiskit_nature.properties.second_quantization.electronic import ElectronicEnergy
from qiskit_nature.properties.second_quantization.electronic.bases import ElectronicBasis

from .point_generator import PointGenerator


class MP2PointGenerator(PointGenerator):
    """Moller-Plesset 2nd order (MP2) initial point generator.

    A class for computing the Moller-Plesset 2nd order (MP2) corrections to use
    as an initial point for VQE alongside a UCC ansatz.

    An MP2PointGenerator should use the same excitations as generated by UCC to
    ensure that the coefficients are mapped correctly.

    The coefficients and energy deltas are computed when the object is
    initialized. The `initial_point` property may then be used with VQE.

    Only initial point values that correspond to double-excitations will be
    non-zero.
    """

    # TODO: Add benchmark demonstrating that using MP2 initial point results in
    # fewer evaluations to reach the ground state.

    def __init__(
        self,
        num_spin_orbitals: int,
        electronic_energy: ElectronicEnergy,
        excitations: List[Tuple[Tuple[int, ...], Tuple[int, ...]]],
        threshold: float = 1e-12,
    ) -> None:
        """
        Args:
            num_spin_orbitals: Number of spin orbitals.
            electronic_energy: Electronic energy grouped property.
            excitations: Sequence of excitations.
            threshold: Computed initial point and energy deltas will be set to
                zero if their value is below this threshold.
        """
        super().__init__()

        self.num_spin_orbitals = num_spin_orbitals
        self.electronic_energy = electronic_energy
        self.excitations = excitations
        self.threshold = threshold

        self._terms = self._compute_corrections()

    @property
    def num_spin_orbitals(self) -> int:
        """The number of spin orbitals."""
        return self._num_spin_orbitals

    @num_spin_orbitals.setter
    def num_spin_orbitals(self, num_spin_orbs: int) -> None:
        """The number of spin orbitals.

        Raises:
            ValueError: For non-positive-definite input.
        """
        if num_spin_orbs <= 0:
            raise ValueError("Number of spin orbitals must be positive definite.")
        self._num_spin_orbitals = num_spin_orbs

    @property
    def electronic_energy(self) -> ElectronicEnergy:
        """The ElectronicEnergy property."""
        return self._electronic_energy

    @electronic_energy.setter
    def electronic_energy(self, elec: ElectronicEnergy) -> None:
        """The ElectronicEnergy property.

        Raises:
            ValueError: If ElectronicEnergy is missing orbital energies.
        """
        orbital_energies = elec.orbital_energies
        if orbital_energies is None:
            raise ValueError("Orbital energies missing from ElectronicEnergy.")

        self._electronic_energy = elec
        self._orbital_energies = orbital_energies
        self._integral_matrix = elec.get_electronic_integral(ElectronicBasis.MO, 2).get_matrix()
        self._reference_energy = elec.reference_energy

    @property
    def excitations(self) -> List[Tuple[Tuple[int, ...], Tuple[int, ...]]]:
        """The sequence of excitations."""
        return self._excitations

    @excitations.setter
    def excitations(self, exs: List[Tuple[Tuple[int, ...], Tuple[int, ...]]]):
        """The sequence of excitations."""
        # TODO: Validate excitation list as is done in UCC?
        self._excitations = exs

    @property
    def threshold(self) -> float:
        """The energy threshold for MP2 computation."""
        return self._threshold

    @threshold.setter
    def threshold(self, thr) -> None:
        """The energy threshold for MP2 computation."""
        if thr <= 0:
            raise ValueError("The energy threshold must be positive definite.")
        self._threshold = thr

    @property
    def initial_point(self) -> np.ndarray:
        """The MP2 coefficients as an initial_point."""
        return np.asarray([val[0] for val in self._terms.values()])

    @property
    def energy_deltas(self) -> np.ndarray:
        """The MP2 energy correction deltas for each excitation."""
        return np.asarray([val[1] for val in self._terms.values()])

    @property
    def energy_delta(self) -> float:
        """The MP2 delta energy correction for the molecule."""
        return sum(self.energy_deltas)

    @property
    def energy(self) -> float:
        """The absolute MP2 energy for the molecule."""
        return self._reference_energy + self.energy_delta

    def _compute_corrections(
        self,
    ) -> Dict[str, Tuple[float, float]]:
        """Compute the MP2 coefficients and energy corrections for each double excitation.

        Non-double excitations will have zero coefficient and energy delta.

        Returns:
            Dictionary with MP2 coefficients and energy_deltas for each excitation
        """
        terms = {}
        for excitation in self._excitations:
            if len(excitation[0]) == 2:
                # MP2 needs double excitations.
                coeff, e_delta = self._compute_correction(excitation)
            else:
                # Leave single excitations unchanged.
                coeff, e_delta = 0.0, 0.0

            terms[str(excitation)] = (coeff, e_delta)

        return terms

    def _compute_correction(
        self, excitation: Tuple[Tuple[int, ...], Tuple[int, ...]]
    ) -> Tuple[float, float]:
        """Compute the MP2 coefficient and energy corrections given a double excitation.

        Each double excitation given by [i,a,j,b] has a coefficient computed using
            coeff = -(2 * T[i,a,j,b] - T[i,b,j,a)/(E[b] + E[a] - E[i] - E[j])
        where E is the orbital energy.
        and an energy delta given by
            e_delta = coeff * T[i,a,j,b]

        All the computations are done using the molecule orbitals but the indices used
        in the excitation information passed in and out are in the block spin orbital
        numbering as normally used by the nature module:
          - alpha runs from 0 to num_orbitals - 1
          - beta runs from num_orbitals to num_orbitals * 2 - 1

        Args:
            excitations: Sequence of excitations.

        Returns:
            Correction coefficients and energy deltas.
        """
        # Since spins are the same drop to MO indexing
        num_orbitals = self._num_spin_orbitals // 2
        i = excitation[0][0] % num_orbitals
        j = excitation[0][1] % num_orbitals
        a = excitation[1][0] % num_orbitals
        b = excitation[1][1] % num_orbitals

        tiajb = self._integral_matrix[i, a, j, b]
        tibja = self._integral_matrix[i, b, j, a]

        num = 2 * tiajb - tibja
        denom = (
            self._orbital_energies[b]
            + self._orbital_energies[a]
            - self._orbital_energies[i]
            - self._orbital_energies[j]
        )
        coeff = -num / denom
        coeff = coeff if abs(coeff) > self._threshold else 0
        e_delta = coeff * tiajb
        e_delta = e_delta if abs(e_delta) > self._threshold else 0

        return (coeff, e_delta)
